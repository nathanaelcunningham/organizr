---
phase: 01.1-qbittorrent-connection-testing
plan: 01
type: execute
---

<objective>
Add backend test endpoint and frontend UI to verify qBittorrent connectivity and authentication.

Purpose: Help users diagnose qBittorrent connection issues before attempting downloads. Addresses ISS-001 discovered during Phase 1 integration testing.
Output: Working connection test button in frontend that calls backend test endpoint and displays success/error status.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ISSUES.md
@.planning/phases/01-qbittorrent-integration/01-01-SUMMARY.md
@.planning/phases/01-qbittorrent-integration/01-02-SUMMARY.md
@backend/internal/qbittorrent/client.go
@backend/internal/server/handlers.go
@backend/internal/server/routes.go
@frontend/src/pages/ConfigPage.tsx
@frontend/src/api/client.ts

**Tech stack available:**
- qBittorrent client with Login() method
- Go Chi router with handler patterns
- React + TypeScript + Zustand stores
- Tailwind CSS for styling

**Established patterns:**
- Repository pattern for data access
- Service layer for business logic
- Background monitoring via goroutines
- Frontend polling for real-time updates
- Error categorization (auth failures, network errors, not found, validation)

**Constraining decisions:**
- Phase 1: qBittorrent Web API integration with cookie-based authentication
- Phase 1: User-friendly error messages without exposing internals
- Phase 1: Retry logic for transient failures (max 3 attempts with 500ms delay)

**Issues being addressed:**
- ISS-001: Add qBittorrent connection test button to frontend (discovered in Phase 1, Plan 2, Task 3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add qBittorrent test endpoint to backend</name>
  <files>backend/internal/server/handlers.go, backend/internal/server/routes.go</files>
  <action>
Add GET endpoint `/api/qbittorrent/test` that creates a qBittorrent client using config values and calls Login(). Return JSON response with success boolean and message string. On success, return {"success": true, "message": "Connected successfully"}. On failure, return {"success": false, "message": "Error description"} with appropriate HTTP status (200 for both - client decides based on success field).

Handler should:
1. Get qBittorrent config from ConfigService (URL, username, password)
2. Create qBittorrent client with NewClient()
3. Call client.Login(ctx)
4. Return structured JSON response

Follow existing handler pattern in handlers.go. Use json.NewEncoder(w).Encode() for response. Handle empty config gracefully (return error if URL/username/password not configured).
  </action>
  <verify>curl http://localhost:8080/api/qbittorrent/test returns JSON with success and message fields</verify>
  <done>Endpoint responds with proper JSON structure for both success and failure cases</done>
</task>

<task type="auto">
  <name>Task 2: Add connection test UI to ConfigPage</name>
  <files>frontend/src/pages/ConfigPage.tsx, frontend/src/api/client.ts</files>
  <action>
Add connection test section to ConfigPage with:
1. "Test Connection" button below qBittorrent config fields
2. Loading state while test is running (show Spinner component)
3. Success state: Green checkmark icon + "Connection successful" message
4. Error state: Red X icon + error message from API

Add API client function in client.ts:
```typescript
export async function testQBittorrentConnection(): Promise<{success: boolean, message: string}> {
  const response = await fetch(`${API_BASE_URL}/api/qbittorrent/test`);
  return response.json();
}
```

UI should:
- Use existing Button component with variant="outline"
- Show inline status below button (not notification toast)
- Clear previous status when clicking test again
- Disable button during test (add disabled prop to Button if needed)
- Use Tailwind classes: text-green-600 for success, text-red-600 for error

Follow existing ConfigPage patterns (ConfigSection, form layout with Tailwind grid). Do not create new components - add inline to ConfigPage.
  </action>
  <verify>npm run dev, visit config page, click "Test Connection" button shows loading â†’ success/error state</verify>
  <done>Button shows loading state, displays success/error message from API, can be re-tested multiple times</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>qBittorrent connection test endpoint and frontend UI</what-built>
  <how-to-verify>
1. Start backend: cd backend && make run
2. Start frontend: cd frontend && npm run dev
3. Visit: http://localhost:5173/config
4. Configure qBittorrent settings (URL, username, password)
5. Click "Test Connection" button
6. Valid credentials: Verify green checkmark + "Connection successful"
7. Invalid credentials: Change password, verify red X + error message
8. Empty config: Clear URL field, verify error message about missing config
9. Network error: Stop backend, verify timeout/network error message
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] GET /api/qbittorrent/test endpoint exists and returns proper JSON
- [ ] Frontend displays test button in ConfigPage
- [ ] Valid credentials show success state
- [ ] Invalid credentials show error state
- [ ] Empty config shows appropriate error
- [ ] UI follows existing patterns (Button component, Tailwind classes)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Connection test works for both success and failure scenarios
- ISS-001 resolved and closed in ISSUES.md
- No TypeScript or Go build errors
- Phase 1.1 complete, ready for Phase 2
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-qbittorrent-connection-testing/01.1-01-SUMMARY.md`:

# Phase 1.1 Plan 1: qBittorrent Connection Testing Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.go` - Description
- `path/to/file.tsx` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 1.1 complete, ready for Phase 2 (Download Monitoring)
</output>
