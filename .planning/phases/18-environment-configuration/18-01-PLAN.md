---
phase: 18-environment-configuration
plan: 01
type: execute
---

<objective>
Implement environment variable support for configuration settings with .env file integration, enabling flexible deployment configuration without database access.

Purpose: Allow deployment-time configuration (qBittorrent URL, credentials, paths) via environment variables or .env files instead of requiring database setup, critical for Docker and Unraid deployments where config should be externalized.

Output: Backend reads configuration from environment variables (with .env fallback), database values remain as defaults/overrides, and example .env.example file documents all available options.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/17-docker-compose-setup/17-01-SUMMARY.md

**Tech stack available:**
- Go 1.25.3 backend with standard library
- Environment variable support via os.Getenv (already used for ORGANIZR_DB_PATH)
- Docker Compose orchestration with environment variables

**Established patterns:**
- Database-driven configuration in configs table (qbittorrent.url, qbittorrent.username, qbittorrent.password, paths.*, mam.*, monitor.*)
- Config service with Get/GetAll/Set methods
- ORGANIZR_DB_PATH environment variable pattern (Phase 17)
- Default values in migrations (001_init.up.sql)

**Constraining decisions:**
- Phase 17: ORGANIZR_DB_PATH env var for database location - establish pattern for environment variables
- Phase 17: Volume mount at /data - database persisted, but config should be deployable via env vars
- Configuration stored in SQLite configs table with key-value structure

**Context for this phase:**
Current state: All configuration stored in database configs table with defaults in migrations. To deploy via Docker/Unraid, users must either:
1. Access container to modify database, OR
2. Use API to update config values

Both approaches are inconvenient for deployment. Industry standard is environment variables for deployment-time config (database credentials, service URLs, paths) with optional .env file support.

**Requirements:**
- Environment variables should take precedence: ENV > Database > Defaults
- Config service should check ENV first, then fall back to database
- .env file support for local development (using standard Go .env library)
- .env.example file documenting all available options
- Existing database config API remains functional (for runtime changes via UI)
- Docker Compose updated to use environment variables instead of hardcoding values

**Config keys to support (from migrations):**
- QBITTORRENT_URL (qbittorrent.url)
- QBITTORRENT_USERNAME (qbittorrent.username)
- QBITTORRENT_PASSWORD (qbittorrent.password)
- PATHS_DESTINATION (paths.destination)
- PATHS_TEMPLATE (paths.template)
- PATHS_NO_SERIES_TEMPLATE (paths.no_series_template)
- PATHS_OPERATION (paths.operation)
- PATHS_LOCAL_MOUNT (paths.local_mount)
- MONITOR_INTERVAL_SECONDS (monitor.interval_seconds)
- MONITOR_AUTO_ORGANIZE (monitor.auto_organize)
- MAM_BASEURL (mam.baseurl)
- MAM_SECRET (mam.secret)
- ORGANIZR_DB_PATH (already exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add .env file loading with godotenv library</name>
  <files>backend/go.mod, backend/go.sum, backend/cmd/api/main.go</files>
  <action>
    Install godotenv library for .env file support: `cd backend && go get github.com/joho/godotenv`

    In backend/cmd/api/main.go, add godotenv import and load .env file at startup (before database initialization):
    ```go
    import "github.com/joho/godotenv"

    func run() error {
        // Load .env file if it exists (ignore error if missing - env vars may be set directly)
        _ = godotenv.Load()

        // Continue with existing database initialization...
    ```

    Use godotenv (not viper or other config libraries) because:
    1. Simple, focused on .env file loading only
    2. Small dependency footprint
    3. Common in Go projects
    4. Doesn't conflict with existing config service
  </action>
  <verify>cd backend && go mod tidy succeeds, go build ./cmd/api succeeds without errors</verify>
  <done>godotenv imported, Load() called at startup, .env file loaded if present, missing file ignored gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Implement environment variable precedence in config service</name>
  <files>backend/internal/config/service.go, backend/internal/config/env_mapping.go (new)</files>
  <action>
    Create backend/internal/config/env_mapping.go with mapping between database keys and environment variable names:
    ```go
    package config

    var envKeyMap = map[string]string{
        "qbittorrent.url":          "QBITTORRENT_URL",
        "qbittorrent.username":     "QBITTORRENT_USERNAME",
        "qbittorrent.password":     "QBITTORRENT_PASSWORD",
        "paths.destination":        "PATHS_DESTINATION",
        "paths.template":           "PATHS_TEMPLATE",
        "paths.no_series_template": "PATHS_NO_SERIES_TEMPLATE",
        "paths.operation":          "PATHS_OPERATION",
        "paths.local_mount":        "PATHS_LOCAL_MOUNT",
        "monitor.interval_seconds": "MONITOR_INTERVAL_SECONDS",
        "monitor.auto_organize":    "MONITOR_AUTO_ORGANIZE",
        "mam.baseurl":              "MAM_BASEURL",
        "mam.secret":               "MAM_SECRET",
    }

    func getEnvKey(dbKey string) string {
        return envKeyMap[dbKey]
    }
    ```

    Modify Service.Get() method to check environment variable first:
    ```go
    func (s *Service) Get(ctx context.Context, key string) (string, error) {
        // Check environment variable first
        if envKey := getEnvKey(key); envKey != "" {
            if envVal := os.Getenv(envKey); envVal != "" {
                return envVal, nil
            }
        }

        // Fall back to database
        value, err := s.repo.Get(ctx, key)
        if err != nil {
            return "", fmt.Errorf("failed to get config %s: %w", key, err)
        }
        return value, nil
    }
    ```

    Modify Service.GetAll() to merge environment variables with database values (ENV takes precedence):
    ```go
    func (s *Service) GetAll(ctx context.Context) (map[string]string, error) {
        // Get database configs
        configs, err := s.repo.GetAll(ctx)
        if err != nil {
            return nil, fmt.Errorf("failed to get all configs: %w", err)
        }

        // Override with environment variables
        for dbKey, envKey := range envKeyMap {
            if envVal := os.Getenv(envKey); envVal != "" {
                configs[dbKey] = envVal
            }
        }

        return configs, nil
    }
    ```

    IMPORTANT: Service.Set() method should continue writing to database only (not modify environment variables - they're read-only).

    This approach maintains backward compatibility: existing database-driven config continues working, but environment variables can override any value at runtime.
  </action>
  <verify>cd backend && go test ./internal/config/... passes, go build ./cmd/api succeeds</verify>
  <done>Config service checks ENV first, falls back to database, GetAll() merges both sources with ENV precedence, Set() writes to database only, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Create .env.example file with documentation</name>
  <files>.env.example</files>
  <action>
    Create .env.example at repository root with all supported environment variables and descriptions:
    ```
    # Organizr Configuration
    # Copy this file to .env and update values for your environment

    # Database
    ORGANIZR_DB_PATH=/data/organizr.db

    # qBittorrent Web UI Configuration
    QBITTORRENT_URL=http://localhost:8080
    QBITTORRENT_USERNAME=admin
    QBITTORRENT_PASSWORD=adminpass

    # Paths Configuration
    # Base directory where organized audiobooks will be stored
    PATHS_DESTINATION=/audiobooks

    # Path template for books WITH series (variables: {author}, {series}, {title}, {series_number})
    PATHS_TEMPLATE={author}/{series}/{title}

    # Path template for books WITHOUT series (variables: {author}, {title})
    PATHS_NO_SERIES_TEMPLATE={author}/{title}

    # File operation: "copy" or "move"
    PATHS_OPERATION=copy

    # Local mount point for qBittorrent downloads (empty for local qBittorrent)
    # Example: /Volumes/data for network share or Docker volume mapping
    PATHS_LOCAL_MOUNT=

    # Monitor Configuration
    # Polling interval in seconds
    MONITOR_INTERVAL_SECONDS=30

    # Auto-organize on download completion: "true" or "false"
    MONITOR_AUTO_ORGANIZE=true

    # MyAnonamouse Configuration
    MAM_BASEURL=https://www.myanonamouse.net
    MAM_SECRET=your_mam_api_secret_here
    ```

    Include comments explaining:
    - What each variable does
    - Expected format/values
    - Default values (matching 001_init.up.sql defaults)
    - When to use certain options (like PATHS_LOCAL_MOUNT)
  </action>
  <verify>File exists at .env.example, all environment variables documented, matches envKeyMap in config/env_mapping.go</verify>
  <done>.env.example created with all config options documented, clear comments, matches database defaults</done>
</task>

<task type="auto">
  <name>Task 4: Update docker-compose.yml to use environment variables</name>
  <files>docker-compose.yml, .env.example</files>
  <action>
    Update docker-compose.yml backend service to use .env file and expose all configuration via environment variables:

    ```yaml
    backend:
      build: ./backend
      ports:
        - "8080:8080"
      env_file:
        - .env
      environment:
        # Override specific variables if needed
        - ORGANIZR_DB_PATH=${ORGANIZR_DB_PATH:-/data/organizr.db}
        - QBITTORRENT_URL=${QBITTORRENT_URL}
        - QBITTORRENT_USERNAME=${QBITTORRENT_USERNAME}
        - QBITTORRENT_PASSWORD=${QBITTORRENT_PASSWORD}
        - PATHS_DESTINATION=${PATHS_DESTINATION}
        - PATHS_TEMPLATE=${PATHS_TEMPLATE:-{author}/{series}/{title}}
        - PATHS_NO_SERIES_TEMPLATE=${PATHS_NO_SERIES_TEMPLATE:-{author}/{title}}
        - PATHS_OPERATION=${PATHS_OPERATION:-copy}
        - PATHS_LOCAL_MOUNT=${PATHS_LOCAL_MOUNT}
        - MONITOR_INTERVAL_SECONDS=${MONITOR_INTERVAL_SECONDS:-30}
        - MONITOR_AUTO_ORGANIZE=${MONITOR_AUTO_ORGANIZE:-true}
        - MAM_BASEURL=${MAM_BASEURL:-https://www.myanonamouse.net}
        - MAM_SECRET=${MAM_SECRET}
      volumes:
        - organizr-data:/data
      # ... rest of backend config unchanged
    ```

    Update .env.example to add note about Docker Compose usage:
    ```
    # Docker Compose Usage
    # This file is automatically loaded by docker-compose.yml
    # Copy to .env and update values before running: docker-compose up
    ```

    IMPORTANT: Keep existing healthcheck, depends_on, networks configuration unchanged.
  </action>
  <verify>docker-compose config validates successfully, environment variables properly templated</verify>
  <done>docker-compose.yml uses env_file and environment variables, .env.example updated with Docker usage notes, configuration externalized from containers</done>
</task>

<task type="auto">
  <name>Task 5: Test environment variable precedence</name>
  <files>backend/internal/config/service_test.go (new)</files>
  <action>
    Create backend/internal/config/service_test.go with tests verifying ENV precedence:

    ```go
    package config_test

    import (
        "context"
        "os"
        "testing"

        "github.com/nathanael/organizr/internal/config"
        // ... mock repository
    )

    func TestService_Get_EnvironmentPrecedence(t *testing.T) {
        tests := []struct {
            name          string
            key           string
            envValue      string
            dbValue       string
            expectedValue string
        }{
            {
                name:          "environment variable overrides database",
                key:           "qbittorrent.url",
                envValue:      "http://env-qbit:8080",
                dbValue:       "http://db-qbit:8080",
                expectedValue: "http://env-qbit:8080",
            },
            {
                name:          "falls back to database when env not set",
                key:           "qbittorrent.url",
                envValue:      "",
                dbValue:       "http://db-qbit:8080",
                expectedValue: "http://db-qbit:8080",
            },
            // ... more test cases for different config keys
        }

        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                // Set up environment
                if tt.envValue != "" {
                    os.Setenv("QBITTORRENT_URL", tt.envValue)
                    defer os.Unsetenv("QBITTORRENT_URL")
                }

                // Mock repository
                mockRepo := &MockConfigRepository{
                    getFunc: func(ctx context.Context, key string) (string, error) {
                        return tt.dbValue, nil
                    },
                }

                svc := config.NewService(mockRepo)
                value, err := svc.Get(context.Background(), tt.key)

                if err != nil {
                    t.Fatalf("unexpected error: %v", err)
                }
                if value != tt.expectedValue {
                    t.Errorf("expected %q, got %q", tt.expectedValue, value)
                }
            })
        }
    }
    ```

    Test coverage:
    - ENV overrides database value
    - Database used when ENV not set
    - GetAll() merges both sources
    - Unknown config keys (no env mapping) use database only

    Use table-driven tests with subtests (established testing pattern).
  </action>
  <verify>cd backend && go test ./internal/config/... -v passes all tests, coverage shows Get/GetAll paths tested</verify>
  <done>Tests verify ENV precedence over database, fallback behavior, GetAll() merging, all passing with good coverage</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cd backend && go build ./cmd/api` succeeds
- [ ] `cd backend && go test ./internal/config/...` passes all tests
- [ ] `docker-compose config` validates successfully
- [ ] .env.example contains all config variables with descriptions
- [ ] godotenv loads .env file at startup
- [ ] Config service checks ENV before database
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- godotenv library integrated
- Config service implements ENV > Database > Defaults precedence
- .env.example documents all configuration options
- docker-compose.yml uses environment variables
- Tests verify precedence behavior
- No regressions in existing config functionality
  </success_criteria>

<output>
After completion, create `.planning/phases/18-environment-configuration/18-01-SUMMARY.md`:

# Phase 18 Plan 01: Environment Configuration Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- [List files with descriptions]

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 19: Volume & Path Management
</output>
