---
phase: 11-api-layer-cleanup
plan: 02
type: execute
---

<objective>
Add comprehensive OpenAPI/Swagger documentation to the API with interactive UI for exploration and testing.

Purpose: Provide machine-readable API specification for tooling and human-readable documentation for developers using the API.
Output: Fully documented API with Swagger UI accessible at /swagger endpoint, auto-generated OpenAPI spec.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-api-layer-cleanup/11-01-SUMMARY.md

# API structure
@backend/internal/server/handlers.go
@backend/internal/server/request_types.go
@backend/internal/server/dto.go
@backend/internal/server/routes.go
@backend/cmd/api/main.go

**Current state:**
- No API documentation exists
- Go backend using Chi router
- ~15 HTTP handlers across downloads, config, search, qBittorrent test
- Request/response types already defined in request_types.go
- DTOs defined in dto.go

**Discovery findings:**
- Use swaggo/swag (standard Go tool for OpenAPI generation)
- Comment-based annotations above handler functions
- Works seamlessly with Chi router
- Generates OpenAPI 2.0/Swagger 2.0 spec (industry standard)
- http-swagger provides UI middleware

**API endpoints to document:**
- Health: GET /api/health
- Downloads: GET/POST /api/downloads, GET/DELETE /api/downloads/{id}, POST /api/downloads/{id}/cancel, POST /api/downloads/{id}/organize, POST /api/downloads/batch
- Config: GET /api/config, GET/PUT /api/config/{key}
- Search: GET /api/search
- QBittorrent: POST /api/qbittorrent/test
- Path Preview: POST /api/path/preview
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install swaggo and add global API documentation</name>
  <files>backend/cmd/api/main.go, backend/go.mod</files>
  <action>
1. Install swaggo dependencies:
   ```bash
   go get -u github.com/swaggo/swag/cmd/swag
   go get -u github.com/swaggo/http-swagger
   go install github.com/swaggo/swag/cmd/swag@latest
   ```

2. Add global API documentation comments in main.go BEFORE the main() function:
   ```go
   // @title Organizr API
   // @version 1.2.0
   // @description API for automating audiobook torrent downloads and organization with qBittorrent integration
   // @contact.name Organizr
   // @host localhost:8080
   // @BasePath /api
   // @schemes http
   ```

3. Add import in main.go:
   ```go
   import _ "github.com/nathanael/organizr/docs"  // Required for swag
   ```

4. Run `swag init -g backend/cmd/api/main.go -o backend/docs` to generate initial docs

WHY swaggo: Industry standard for Go API documentation, code-first approach keeps docs close to implementation, prevents drift.

WHY these annotations: Provides Swagger UI with basic API metadata (title, version, description, base URL).
  </action>
  <verify>
go build backend/cmd/api succeeds
backend/docs/docs.go and backend/docs/swagger.json exist after running swag init
No compilation errors from import
  </verify>
  <done>
swaggo dependencies installed in go.mod
Global API documentation comments exist in main.go
backend/docs/ directory created with generated OpenAPI spec
Build succeeds with docs import
  </done>
</task>

<task type="auto">
  <name>Task 2: Annotate all HTTP handlers with OpenAPI documentation</name>
  <files>backend/internal/server/handlers.go</files>
  <action>
Add OpenAPI annotations above each handler function using this pattern:

**Health endpoint:**
```go
// handleHealth godoc
// @Summary Health check
// @Description Check API and dependency health status
// @Tags system
// @Produce json
// @Success 200 {object} HealthResponse
// @Router /health [get]
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
```

**For each endpoint, document:**
1. Summary (one-line description)
2. Description (detailed explanation)
3. Tags (group by: downloads, config, search, system, qbittorrent)
4. Accept/Produce (application/json for all)
5. Param (path params, query params, body params)
6. Success responses with schema (200, 201)
7. Failure responses with ErrorResponse (400, 404, 500)
8. Router (path and method)

**Parameter examples:**
- Path: `@Param id path string true "Download ID (UUID)"`
- Query: `@Param q query string true "Search query" minlength(2)`
- Body: `@Param request body CreateDownloadRequest true "Download request"`

**Response examples:**
- Success: `@Success 200 {object} GetDownloadResponse`
- Error: `@Failure 404 {object} ErrorResponse`

Document all ~15 handlers systematically:
- handleHealth
- handleCreateDownload
- handleListDownloads
- handleGetDownload
- handleCancelDownload
- handleOrganizeDownload
- handleBatchCreateDownload
- handleGetConfig
- handleGetAllConfig
- handleUpdateConfig
- handleSearch
- handleTestQBittorrent
- handlePreviewPath

WHY comprehensive docs: API consumers need to understand request/response schemas, error cases, and parameter requirements. Complete docs improve developer experience.

WHY not skipping errors: Error response documentation is critical for proper error handling in API clients.
  </action>
  <verify>
All handler functions have godoc comment line (required by swag)
All handlers have @Summary, @Router annotations at minimum
swag init runs without errors
Generated swagger.json contains all documented endpoints
  </verify>
  <done>
All 15 HTTP handlers have OpenAPI annotations
Each annotation includes Summary, Tags, Parameters, Success, Failure, Router
swag init generates complete API specification
No missing endpoints in generated documentation
  </done>
</task>

<task type="auto">
  <name>Task 3: Mount Swagger UI and regenerate documentation</name>
  <files>backend/internal/server/routes.go, backend/internal/server/server.go</files>
  <action>
1. Add http-swagger import to routes.go:
   ```go
   import httpSwagger "github.com/swaggo/http-swagger"
   ```

2. Mount Swagger UI endpoint in routes.go (in setupRoutes function):
   ```go
   // Swagger documentation
   r.Get("/swagger/*", httpSwagger.Handler(
       httpSwagger.URL("/swagger/doc.json"),
   ))
   ```

3. Regenerate documentation with all annotations:
   ```bash
   swag init -g backend/cmd/api/main.go -o backend/docs
   ```

4. Verify Swagger UI is accessible (build and run server, check /swagger/index.html in browser would work)

5. Update .gitignore to include generated docs:
   ```
   backend/docs/docs.go
   backend/docs/swagger.json
   backend/docs/swagger.yaml
   ```
   (These are auto-generated, should be regenerated in CI/CD)

WHY mount at /swagger: Standard convention, discoverable endpoint for API documentation.

WHY regenerate: Ensures all handler annotations are included in final OpenAPI spec.

WHY gitignore docs: Generated files should be recreated from source annotations, not committed (prevents drift).
  </action>
  <verify>
go build backend/cmd/api succeeds
Server starts without errors
GET /swagger/index.html would return Swagger UI HTML (verify route exists)
backend/docs/ contains up-to-date generated files
.gitignore includes docs directory
  </verify>
  <done>
Swagger UI endpoint mounted at /swagger
Documentation fully regenerated with all handler annotations
Server builds and starts successfully
Swagger UI accessible via /swagger endpoint
Generated docs ignored by git
Complete API documentation available for developers
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build backend/cmd/api` succeeds without errors
- [ ] `swag init -g backend/cmd/api/main.go -o backend/docs` runs without errors
- [ ] All 15 handlers have OpenAPI annotations
- [ ] backend/docs/swagger.json exists and contains all endpoints
- [ ] Swagger UI route mounted at /swagger
- [ ] Generated docs included in .gitignore
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- swaggo/swag installed and configured
- Global API metadata documented in main.go
- All HTTP handlers have comprehensive OpenAPI annotations
- Swagger UI endpoint accessible at /swagger
- Complete OpenAPI specification generated
- No compilation errors
- Documentation reflects current API state
</success_criteria>

<output>
After completion, create `.planning/phases/11-api-layer-cleanup/11-02-SUMMARY.md`:

# Phase 11 Plan 2: OpenAPI/Swagger Documentation Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 11-03-PLAN.md (Response Pattern Standardization)
</output>
