---
phase: 17-docker-compose-setup
plan: 01
type: execute
---

<objective>
Configure Docker Compose for multi-container orchestration with backend, frontend, and volume management.

Purpose: Enable single-command deployment of the full application stack with proper networking, persistence, and service dependencies.
Output: Working docker-compose.yml that orchestrates backend, frontend, and database volumes with health checks and service dependencies.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-docker-foundation/16-01-SUMMARY.md
@backend/Dockerfile
@frontend/Dockerfile

**Tech stack available:**
- Docker multi-stage builds for backend (Go + SQLite) and frontend (React + nginx)
- Backend: Chi router, SQLite database, qBittorrent client, port 8080
- Frontend: React 19, Vite build, nginx serving, port 8080
- Both containers run as non-root user (uid/gid 1001)

**Established patterns:**
- Backend stores database at `./organizr.db` (hardcoded path)
- Backend config stored in SQLite (qBittorrent URL, credentials, templates)
- Frontend uses VITE_API_URL environment variable for backend connection
- nginx serves on port 8080 (non-privileged port for non-root user)

**Constraining decisions:**
- Phase 16: Non-root containers (uid/gid 1001) for security
- Phase 16: Backend requires CGO_ENABLED=1 for SQLite (already in Dockerfile)
- Phase 16: nginx on port 8080 for non-root compatibility
- Backend hardcodes database path - will need volume mount at /app

**Current state:**
- Dockerfiles exist and build successfully
- Backend: ~32MB image
- Frontend: ~54MB image
- No compose configuration yet
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.yml with service orchestration</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml at project root with:

**Services:**
- `backend`: Build from ./backend/Dockerfile, expose port 8080, mount volume for database persistence at `/data` (mapped to `./organizr.db` location), depends_on frontend with condition: service_healthy
- `frontend`: Build from ./frontend/Dockerfile, expose port 8081 (map container 8080 to host 8081 to avoid conflict with backend), set VITE_API_URL to http://backend:8080 (internal docker network), depends_on backend with condition: service_healthy

**Volumes:**
- `organizr-data`: Named volume for backend database persistence (mount to /app in backend container where organizr.db lives)

**Networks:**
- Default bridge network is sufficient - services can reach each other by service name

**Health checks:**
- Backend: HTTP GET /api/health endpoint (if exists) or skip if not implemented yet - use `wget --no-verbose --tries=1 --spider http://localhost:8080/api/health || exit 1`, interval 10s, timeout 5s, retries 3
- Frontend: HTTP GET / on port 8080, same health check pattern

**Important:**
- Use `build: ./backend` and `build: ./frontend` (no need for context/dockerfile split since Dockerfile is at default location)
- Frontend VITE_API_URL must point to `http://backend:8080` for inter-container communication (NOT localhost)
- Map frontend to host port 8081 (not 8080) to avoid conflict with backend on host
- Backend database volume must mount to `/app` directory where the binary expects `./organizr.db`
- Use compose file version 3.8+ (or omit version - modern compose doesn't require it)

**Don't:**
- Don't add restart policies yet (Phase 18 for production config)
- Don't add .env file yet (Phase 18 for environment configuration)
- Don't configure reverse proxy or SSL (Phase 20 for deployment docs)
  </action>
  <verify>docker-compose config validates without errors</verify>
  <done>Valid docker-compose.yml exists, validates successfully, defines backend and frontend services with volume and health checks</done>
</task>

<task type="auto">
  <name>Task 2: Add .dockerignore at project root</name>
  <files>.dockerignore</files>
  <action>
Create .dockerignore at project root to optimize build context when using docker-compose:

**Exclude:**
- .git/ and .github/
- .planning/ (phase docs not needed in images)
- node_modules/ (frontend has its own .dockerignore but good to exclude at root)
- Backend compiled binary (backend/organizr)
- Database files (*.db, *.db-shm, *.db-wal)
- OS files (.DS_Store)
- IDE files (.vscode/, .idea/)
- Documentation (*.md) except README.md

**Keep:**
- backend/ and frontend/ directories (needed for builds)
- README.md (useful in images for reference)

This is in addition to the backend/.dockerignore and frontend/.dockerignore files created in Phase 16.
  </action>
  <verify>cat .dockerignore shows expected exclusions</verify>
  <done>.dockerignore exists at project root with comprehensive exclusions for docker-compose builds</done>
</task>

<task type="auto">
  <name>Task 3: Test compose orchestration</name>
  <files>None</files>
  <action>
Build and start services with docker-compose:

1. Clean any existing containers: `docker-compose down -v` (removes volumes too)
2. Build images: `docker-compose build --no-cache` (fresh build to verify Dockerfiles work)
3. Start services: `docker-compose up -d` (detached mode)
4. Check service status: `docker-compose ps` (both should show "Up" or "running")
5. Check logs: `docker-compose logs backend` and `docker-compose logs frontend` (no critical errors)
6. Verify backend health: `curl http://localhost:8080/api/health` or `curl http://localhost:8080/api/config` (config endpoint should work)
7. Verify frontend: `curl http://localhost:8081` (should return HTML)
8. Verify inter-service communication: Frontend should be able to call backend via docker network
9. Stop services: `docker-compose down` (but keep volume for next phase)

**Expected behavior:**
- Both services build without errors
- Backend starts and initializes SQLite database in mounted volume
- Frontend serves on port 8081 and can reach backend at http://backend:8080
- Health checks pass (or services stay up if health checks not implemented)
- Database persists after `docker-compose down` (volume retained)

**If health endpoint doesn't exist:**
- Remove health check conditions from docker-compose.yml and rely on service startup only
- Or implement simple /api/health endpoint in backend first (quick handler that returns 200 OK)
  </action>
  <verify>docker-compose up -d succeeds, docker-compose ps shows both services running, curl to both ports returns expected responses</verify>
  <done>Services orchestrate successfully, frontend can reach backend, database persists in volume, no errors in logs</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] docker-compose config validates
- [ ] docker-compose build succeeds for both services
- [ ] docker-compose up -d starts both services successfully
- [ ] Backend accessible on http://localhost:8080
- [ ] Frontend accessible on http://localhost:8081
- [ ] Frontend can communicate with backend via docker network
- [ ] Database persists after docker-compose down (volume retained)
- [ ] No errors in docker-compose logs
</verification>

<success_criteria>

- docker-compose.yml exists and validates
- Both services build and start successfully
- Services can communicate via docker network
- Database volume provides persistence
- Documentation updated with compose usage
  </success_criteria>

<output>
After completion, create `.planning/phases/17-docker-compose-setup/17-01-SUMMARY.md`:

# Phase 17 Plan 01: Docker Compose Setup Summary

**[One-liner describing what was built]**

## Accomplishments

- Created docker-compose.yml for multi-container orchestration
- Configured services, volumes, and networking
- [Other accomplishments]

## Files Created/Modified

- `docker-compose.yml` - Multi-container orchestration config
- `.dockerignore` - Build context optimization for compose
- [Any other files]

## Decisions Made

[Key decisions about compose configuration, health checks, port mappings, volume strategy, or "None"]

## Issues Encountered

[Problems discovered during testing and how they were resolved, or "None"]

## Next Phase Readiness

Ready for Phase 18 (Environment Configuration). Docker Compose orchestrates services successfully. Next phase will add .env file support and externalize configuration.

## Commit References

- Task 1 (docker-compose.yml): [commit hash]
- Task 2 (.dockerignore): [commit hash]
- Task 3 (Testing and docs): [commit hash]

Phase 17-01 complete - ready for next phase.
</output>
