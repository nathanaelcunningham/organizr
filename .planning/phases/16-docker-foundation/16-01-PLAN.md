---
phase: 16-docker-foundation
plan: 01
type: execute
---

<objective>
Create production-ready Dockerfiles for backend and frontend with multi-stage builds for optimized image sizes.

Purpose: Enable containerized deployment with minimal, secure images following 2026 best practices.
Output: Backend Dockerfile (Go multi-stage), Frontend Dockerfile (Node + nginx), .dockerignore files for both.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/codebase/STRUCTURE.md

**Tech stack available:**
- Backend: Go 1.25.3, CGO_ENABLED=1 (SQLite requirement)
- Frontend: Node.js, React 19.2.0, Vite 7.2.4, TypeScript 5.9.3
- Build commands: `go build -o bin/organizr ./cmd/api` (backend), `npm run build` (frontend)

**Build artifacts:**
- Backend: `bin/organizr` binary (requires CGO for SQLite)
- Frontend: `dist/` directory with static assets

**Docker best practices (from discovery):**
- Multi-stage builds: separate build environment from runtime
- Go: Build with full toolchain, run on minimal alpine image
- Frontend: Build with Node, serve with nginx:alpine
- Non-root user for security
- Layer caching optimization (COPY package files first)
- Build flags for Go: `-ldflags="-s -w"` for smaller binaries
- CGO_ENABLED=1 required for SQLite support
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend Dockerfile with multi-stage build</name>
  <files>backend/Dockerfile, backend/.dockerignore</files>
  <action>
Create multi-stage Dockerfile for Go backend:

**Stage 1 - Build:**
- FROM golang:1.25-alpine AS build
- Install build dependencies: `apk add --no-cache gcc musl-dev sqlite-dev` (required for CGO/SQLite)
- WORKDIR /app
- COPY go.mod go.sum, RUN go mod download (layer caching)
- COPY rest of source
- Build with: `CGO_ENABLED=1 GOOS=linux go build -ldflags="-s -w" -o organizr ./cmd/api`
- Use `-ldflags="-s -w"` to strip debug symbols for smaller binary

**Stage 2 - Runtime:**
- FROM alpine:3.21
- Install runtime dependencies: `apk add --no-cache ca-certificates sqlite-libs` (SQLite shared libraries needed)
- Create non-root user: `addgroup -g 1001 app && adduser -S app -u 1001 -G app`
- WORKDIR /app
- COPY --from=build --chown=app:app /app/organizr /app/organizr
- COPY --from=build --chown=app:app /app/assets /app/assets (database migrations)
- USER app
- EXPOSE 8080
- CMD ["/app/organizr"]

**Create .dockerignore:**
```
# Build artifacts
bin/
*.db
*.db-shm
*.db-wal

# Development files
.air.toml
coverage.html
coverage.out
*.test

# Documentation
README.md
FIX_SUMMARY.md
TEST_MAM_SERIES.md

# Git
.git/
.gitignore
```

Why CGO_ENABLED=1: SQLite driver requires CGO. Must have gcc/musl-dev for build, sqlite-libs for runtime.
Why alpine over scratch: Need ca-certificates for HTTPS calls to qBittorrent and MAM, sqlite-libs for database.
  </action>
  <verify>
docker build -t organizr-backend ./backend
docker images organizr-backend (check image size, should be &lt;50MB)
  </verify>
  <done>Backend Dockerfile builds successfully, image is optimized (&lt;50MB), includes migrations, runs as non-root user</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend Dockerfile with multi-stage build</name>
  <files>frontend/Dockerfile, frontend/.dockerignore</files>
  <action>
Create multi-stage Dockerfile for React frontend:

**Stage 1 - Build:**
- FROM node:24-alpine AS build
- WORKDIR /app
- COPY package*.json ./
- RUN npm ci --no-audit --no-fund (production dependencies only)
- COPY rest of source (respects .dockerignore)
- RUN npm run build (outputs to dist/)
- Build produces static files in dist/ directory

**Stage 2 - Runtime (nginx):**
- FROM nginx:alpine
- Create non-root user: `addgroup -g 1001 app && adduser -S app -u 1001 -G app`
- COPY custom nginx.conf to /etc/nginx/nginx.conf (configure for SPA)
- COPY --from=build /app/dist /usr/share/nginx/html
- EXPOSE 80
- USER app
- CMD ["nginx", "-g", "daemon off;"]

**nginx.conf for SPA:**
```nginx
user app;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /tmp/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    keepalive_timeout 65;
    gzip on;

    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;

        # SPA routing: serve index.html for all routes
        location / {
            try_files $uri $uri/ /index.html;
        }

        # Cache static assets
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

**Create .dockerignore:**
```
# Dependencies
node_modules/

# Build output
dist/

# Development files
.env.development
coverage/

# Test files
src/test/
*.test.ts
*.test.tsx
vitest.config.ts

# Documentation
README.md

# Config
.prettierignore
.prettierrc.json
eslint.config.js

# Git
.git/
.gitignore
```

Why nginx over Node: Nginx is more efficient for serving static files, smaller image, production-standard.
Why alpine: Minimal size while still providing necessary tools.
  </action>
  <verify>
docker build -t organizr-frontend ./frontend
docker images organizr-frontend (check image size, should be &lt;30MB)
docker run -d -p 8081:80 organizr-frontend (test serving)
curl http://localhost:8081 (should return index.html)
  </verify>
  <done>Frontend Dockerfile builds successfully, nginx serves SPA correctly with proper routing, image is optimized (&lt;30MB)</done>
</task>

<task type="auto">
  <name>Task 3: Test Docker builds and document usage</name>
  <files>backend/Dockerfile, frontend/Dockerfile</files>
  <action>
Verify both Dockerfiles build successfully and document basic usage:

**Build tests:**
1. Build backend: `docker build -t organizr-backend ./backend`
2. Build frontend: `docker build -t organizr-frontend ./frontend`
3. Check image sizes: `docker images | grep organizr`
4. Verify layers are optimized (inspect layer sizes with `docker history`)

**Quick smoke test:**
1. Run frontend: `docker run -d -p 8081:80 --name test-frontend organizr-frontend`
2. Test access: `curl http://localhost:8081` (should return HTML)
3. Clean up: `docker rm -f test-frontend`

**Add usage notes to phase documentation:**
Create brief note in phase directory explaining:
- How to build images
- Expected image sizes (backend ~40-50MB, frontend ~25-30MB)
- Basic run commands (full orchestration in Phase 17)
- Note: Backend needs volumes for database, full config in Phase 17-19

Do NOT create comprehensive README or documentation - that's Phase 20. Just add a simple NOTES.md in the phase directory for reference during subsequent phases.
  </action>
  <verify>
Both images build without errors
Image sizes are optimized (backend &lt;50MB, frontend &lt;30MB)
Frontend container serves index.html successfully
NOTES.md created with basic build/run commands
  </verify>
  <done>Docker images build successfully, sizes are optimized, basic functionality verified, usage notes documented</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `docker build -t organizr-backend ./backend` succeeds
- [ ] `docker build -t organizr-frontend ./frontend` succeeds
- [ ] Backend image size &lt;50MB, frontend &lt;30MB
- [ ] Both Dockerfiles follow multi-stage pattern
- [ ] Both .dockerignore files present and comprehensive
- [ ] Non-root users configured in both images
- [ ] nginx.conf handles SPA routing correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Backend Dockerfile with CGO support for SQLite
- Frontend Dockerfile with nginx serving
- .dockerignore files optimize build context
- Images are production-ready and secure
- Basic usage documented for next phases
  </success_criteria>

<output>
After completion, create `.planning/phases/16-docker-foundation/16-01-SUMMARY.md`:

# Phase 16 Plan 01: Docker Foundation Summary

**Production-ready Dockerfiles with optimized multi-stage builds for backend and frontend.**

## Accomplishments

- Backend Dockerfile: Go multi-stage build with CGO support for SQLite
- Frontend Dockerfile: Node build + nginx serving with SPA routing
- Comprehensive .dockerignore files for both services
- Images optimized for size and security (non-root users)
- Basic build/run documentation for subsequent phases

## Files Created/Modified

- `backend/Dockerfile` - Multi-stage Go build with alpine runtime
- `backend/.dockerignore` - Optimized build context exclusions
- `frontend/Dockerfile` - Multi-stage Node build with nginx serving
- `frontend/.dockerignore` - Optimized build context exclusions
- `frontend/nginx.conf` - nginx configuration for SPA routing
- `.planning/phases/16-docker-foundation/NOTES.md` - Basic usage reference

## Decisions Made

- CGO_ENABLED=1 for SQLite support (requires gcc at build, sqlite-libs at runtime)
- Alpine base images for minimal size (vs scratch - need ca-certificates and libraries)
- nginx over Node.js for frontend serving (more efficient, production-standard)
- Non-root users (uid/gid 1001) for security
- Build flags `-ldflags="-s -w"` for smaller Go binary
- nginx serves on port 80 (standard), backend on port 8080

## Issues Encountered

None

## Next Phase Readiness

Ready for Phase 17 (Docker Compose Setup). Images build successfully and can be orchestrated with docker-compose.

Phase 16 complete - ready for next phase.
</output>
